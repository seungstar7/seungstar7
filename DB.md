# DB

---

### 🍬 정규화(Normalization)란?

👉 **데이터를 예쁘게 정리하는 과정**이야.
데이터베이스에서 **중복되는 내용(같은 말 여러 번 적는 것)**을 줄이고,
**필요한 정보만 딱 정리**해서 넣는 걸 말해.

---

### 🍭 예시로 설명해볼게

어린이집에서 “친구들 정보를 적는 표”를 만든다고 하자.

#### 📋 처음 만든 표

| 이름 | 반   | 선생님 | 선생님 전화번호      |
| -- | --- | --- | ------------- |
| 철수 | 토끼반 | 민지쌤 | 010-1111-1111 |
| 영희 | 토끼반 | 민지쌤 | 010-1111-1111 |
| 민호 | 사자반 | 수진쌤 | 010-2222-2222 |

이 표는 보기엔 괜찮아 보이지만… 문제가 있어 ❗

**문제점:**

* ‘민지쌤’이 바뀌면 → ‘토끼반’ 아이들 모두 전화번호를 일일이 고쳐야 해.
* ‘민지쌤’ 정보가 **중복**돼서 여러 번 들어있지?

---

### 🍎 그래서 “정규화”를 하는 거야!

#### ✅ 1차 정규화 (1NF):

👉 표 안에 **반복되는 데이터가 없게** 만들기
(지금 표는 이미 잘 되어 있어서 OK)

#### ✅ 2차 정규화 (2NF):

👉 **한 줄(행)**이 한 가지 정보만 가지게!
즉, “반 정보는 반 표로 따로 빼기”

📘 <학생표>

| 이름 | 반   |
| -- | --- |
| 철수 | 토끼반 |
| 영희 | 토끼반 |
| 민호 | 사자반 |

📗 <반표>

| 반   | 선생님 | 선생님 전화번호      |
| --- | --- | ------------- |
| 토끼반 | 민지쌤 | 010-1111-1111 |
| 사자반 | 수진쌤 | 010-2222-2222 |

👉 이제 선생님이 바뀌면 “반표” 하나만 수정하면 돼!

#### ✅ 3차 정규화 (3NF):

👉 **반에 대한 정보는 반표에, 선생님에 대한 정보는 선생님표에!**
선생님이 여러 반을 맡을 수도 있으니까 분리하자.

📘 <학생표>

| 이름 | 반   |
| -- | --- |
| 철수 | 토끼반 |
| 영희 | 토끼반 |
| 민호 | 사자반 |

📗 <반표>

| 반   | 선생님 |
| --- | --- |
| 토끼반 | 민지쌤 |
| 사자반 | 수진쌤 |

📙 <선생님표>

| 선생님 | 전화번호          |
| --- | ------------- |
| 민지쌤 | 010-1111-1111 |
| 수진쌤 | 010-2222-2222 |

---

### 🍉 요약하면

| 단계  | 핵심 내용            | 비유                |
| --- | ---------------- | ----------------- |
| 1NF | 같은 칸에 여러 값 넣지 말기 | 한 칸엔 한 가지 정보만     |
| 2NF | 부분적 중복 없애기       | “반 정보”는 따로 표로     |
| 3NF | 간접 중복 없애기        | “선생님 정보”는 또 따로 표로 |

---

정리하자면 👉
**정규화란, 표를 여러 개로 나누어서 “한 가지 정보만 깔끔하게 저장”하는 과정이야.**
이렇게 하면 나중에 데이터 바꿀 때 실수도 줄고, 관리도 쉬워져! 🎯

---

좋아 👍
이제 **정보처리기사 실기 – 데이터베이스(DB) 파트**로 넘어가자.
이건 실기에서 **가장 많이 출제되는 핵심 단원 중 하나야.**
특히 **SQL 작성, 정규화, 트랜잭션, 무결성, 키 제약조건** 같은 부분이 거의 매회 나온다.

---

## 🌟 1. 데이터베이스 핵심 개념 정리

### 📘 1) 데이터베이스 정의

* **정의** : 여러 사용자가 **공유**하고 **통합**, **저장**, **운용**하는 데이터의 집합.
* **특징**
  ① **실시간 접근성 (Real-time Access)**
  ② **계속적인 변화 (Continuous Evolution)**
  ③ **내용에 의한 참조 (Content Reference)**
  ④ **동시 공유 (Concurrent Sharing)**

---

## 🔑 2. 데이터베이스 키(Key)

| 키 종류                   | 설명                             | 예시             |
| ---------------------- | ------------------------------ | -------------- |
| **슈퍼키(Super Key)**     | 튜플을 유일하게 식별할 수 있는 속성들의 집합      | {학번}, {학번, 이름} |
| **후보키(Candidate Key)** | 최소성 가진 슈퍼키 (필요 최소한만 포함)        | {학번}           |
| **기본키(Primary Key)**   | 후보키 중 대표로 선택된 키 (NULL ❌, 중복 ❌) | 학번             |
| **대체키(Alternate Key)** | 기본키로 선택되지 않은 후보키               | 주민번호           |
| **외래키(Foreign Key)**   | 다른 테이블의 기본키를 참조하는 키            | 학번(FK) → 학생.학번 |

🧠 **자주 출제 포인트**

* “기본키는 NULL을 허용하지 않는다.” → ✅ 참
* “외래키는 참조 무결성을 유지하기 위해 사용된다.” → ✅ 참

---

## 📊 3. 무결성 제약조건 (Integrity Constraints)

| 제약조건                              | 의미                                |
| --------------------------------- | --------------------------------- |
| **개체 무결성(Entity Integrity)**      | 기본키는 NULL ❌, 중복 ❌                 |
| **참조 무결성(Referential Integrity)** | 외래키는 참조하는 기본키 값과 일치해야 함           |
| **도메인 무결성(Domain Integrity)**     | 속성 값은 정의된 도메인(자료형, 범위 등) 안에 있어야 함 |

---

## ⚙️ 4. 정규화 (Normalization)

> 데이터 **중복 최소화**, **삽입/삭제 이상(anomaly)** 방지 목적

| 단계            | 기준                              | 예시          |
| ------------- | ------------------------------- | ----------- |
| **1정규형(1NF)** | 속성값이 원자값이어야 함                   | 중복 필드 분리    |
| **2정규형(2NF)** | 부분 함수 종속 제거 (기본키 일부 → 종속 ❌)     | 복합키 사용 시    |
| **3정규형(3NF)** | 이행적 함수 종속 제거 (A→B, B→C이면 A→C ❌) | 비키→비키 종속 제거 |

🧩 **출제 예시**

> “어떤 테이블에서 기본키의 일부 속성에 종속된 비기본키 속성이 존재한다면?”
> → ❌ 2정규형 위배

---

## 💾 5. 트랜잭션 (Transaction)

> 데이터베이스의 **논리적 작업 단위**

### 💡 4대 특성 (ACID)

| 특성                    | 설명                    |
| --------------------- | --------------------- |
| **Atomicity (원자성)**   | 전부 수행 or 전부 취소        |
| **Consistency (일관성)** | 실행 전후 DB 일관성 유지       |
| **Isolation (독립성)**   | 동시에 여러 트랜잭션 수행 시 간섭 ❌ |
| **Durability (영속성)**  | 완료된 트랜잭션은 DB에 영구 반영   |

---

## 🧱 6. SQL 명령어 정리

| 분류      | 명령어                            | 설명      |
| ------- | ------------------------------ | ------- |
| **DDL** | CREATE, ALTER, DROP            | 구조 정의   |
| **DML** | SELECT, INSERT, UPDATE, DELETE | 데이터 조작  |
| **DCL** | GRANT, REVOKE                  | 권한 제어   |
| **TCL** | COMMIT, ROLLBACK, SAVEPOINT    | 트랜잭션 제어 |

---

## 🔥 7. 자주 나오는 SQL 예시

### ✅ (1) SELECT 문 기본

```sql
SELECT 이름, 학번
FROM 학생
WHERE 학과 = '컴퓨터공학과'
ORDER BY 학번 DESC;
```

### ✅ (2) GROUP BY + HAVING

```sql
SELECT 학과, COUNT(*) AS 인원수
FROM 학생
GROUP BY 학과
HAVING COUNT(*) >= 30;
```

### ✅ (3) JOIN

```sql
SELECT S.이름, D.학과명
FROM 학생 S
JOIN 학과 D ON S.학과코드 = D.학과코드;
```

---

### 🧩 **DB 설계 4단계 핵심 요약**

| 단계      | 이름                                 | 핵심 내용                   | 결과물 / 포인트                                      |
| ------- | ---------------------------------- | ----------------------- | ---------------------------------------------- |
| **1단계** | **요구사항 분석 (Requirement Analysis)** | 사용자·업무의 데이터 요구를 수집하고 정리 | 요구사항 명세서 (엔터티 후보, 속성 목록 등)                     |
| **2단계** | **개념적 설계 (Conceptual Design)**     | 현실 세계 → 개념적 구조로 변환      | **ER 다이어그램 (Entity, Attribute, Relationship)** |
| **3단계** | **논리적 설계 (Logical Design)**        | DBMS에 맞게 스키마 구조 설계      | **릴레이션 스키마**, 정규화 수행                           |
| **4단계** | **물리적 설계 (Physical Design)**       | 실제 저장 구조, 인덱스, 접근 경로 설계 | **저장 구조, 인덱스 설계, 성능 최적화**                      |

---

### 💡 암기 팁

> **요개논물 (요구 → 개념 → 논리 → 물리)**
> 👉 “요개논물 = 요(구)개(념)논(리)물(리)” 이렇게 리듬감 있게 외우면 잘 안 잊혀.

